---
title: "How to Create a Custom Email Signup Form for ConvertKit on GatsbyJS."
date: "2021-05-01"
tags: ["GatsbyJS"]
slug: custom-email-signup-form-conertkit-gatsbyjs
image: ./custom-email-signup-form-conertkit-gatsbyjs.png
published: true
canonical_url: ""
description: ""
---

There's 4 parts to building a custom subscriber form:

1. The signup component users will interact with.
2. A custom hook to handle the form changes.
3. A custom hook to handle the submitting of the form.
4. A serverless function to actually submit the request.

## The Signup Component

Because we are just building an email signup form the only inputs we need is an text input for the email and a submit button.

Here's a look at the code:

```JS
export const EmailSignup = () => {
	const { values, updateValue } = useForm({
		email: '',
	});

	const { message, loading, error, submitEmail } = useEmail({ values });
	const { email } = values;

	return (
		<>
			<FormGridContainer onSubmit={submitEmail}>
				<fieldset disabled={loading}>
					<label htmlFor="email">
						Email:
							<input
							type="email"
							name="email"
							id={`email-${Math.random().toString(36).substring(2, 15)}`}
							className="emailInput"
							onChange={updateValue}
							value={email}
						/>
					</label>
				</fieldset>
				<button className="signupButton" type="submit" disabled={loading}>
					{loading ? 'Subscribing...' : ' Subscribe'}
				</button>
			</FormGridContainer>
			{message ? <OutcomeMessageContainer error={error} message={message} /> : ''}
		</>
	);
};
```

In the first part of the code, we handle passing data to and receiving back from the 2 helper functions that we will create `useForm` and `useEmail`.

Then for the rest of the component we just handle displaying the data back to the user in the form and creating elements for them to interact with.

The only other part to note is at the bottom of the code we mention another component `OutcomeMessageContainer` this is just a styled-component which looks like this:

```js
const OutcomeMessageContainer = ({ error, message }) => (
  <MessageContainer>
    {error ? <FaTimes data-error /> : <FaCheck />}
    <p>{message}</p>
  </MessageContainer>
);
```

As you can see we just pass in 2 props, the error if there is one and the message returned back from the serverless function and then display this to the user.

Now, let's look at the first helper function: `useForm`.

## useForm

`useForm` is a small helper function to aid in the recording and displaying of information in a form as the user types in it.

It can automatically expand to include new values if required.

This is important because we want an easy way to access the typed information to pass to the next helper function `useEmail`.

Here's the code for `useForm`.

```js
import { useState } from "react";

export default function useForm(defaults) {
  const [values, setValues] = useState(defaults);

  function updateValue(e) {
    // Get value from the changed field using the event.
    const { value } = e.target;

    // Set the value by spreading in the existing values and chaging the key to the new value or adding it if not previously present.
    setValues({
      ...values,
      [e.target.name]: value,
    });
  }

  return { values, updateValue };
}
```

Essentially, it boils down to a `setState` hook and a function to set the state.

The state it sets is an object containing the current values and any added ones if the index value didn't exist before.

For example, in our case the object set to state would look like:

```js
{
  email: "example@example.com";
}
```

If we then look back at our original component where we consume this function you can see how we use it:

```js
const { values, updateValue } = useForm({
  email: "",
});

const { email } = values;
```

In the first line, we destructure out the `values` and the `updateValue` function that we defined in the helper. Then we destructure out the values we need on the second line.

In the next line we pass in default values to the hook. We do this because otherwise when we access the `email` value it won't exist causing an error. So to prevent this we create all of the required state on load with a default value.

We then update this state later on.

Then on the input element in the form, we pass the `updateValue` function as the `onChange` handler like so:

```js
<input
	  type="email"
	  name="email"
	  id={`email-${Math.random().toString(36).substring(2, 15)}`}
	  className="emailInput"
	  onChange={updateValue}
	  value={email}
	/>
</label>
```

How does it know what index to update you may be asking?

Well, looking back at our `useForm` code, in the `updateValue` function:

```js
function updateValue(e) {
  // Get value from the changed field using the event.
  const { value } = e.target;

  // Set the value by spreading in the existing values and chaging the key to the new value or adding it if not previously present.
  setValues({
    ...values,
    [e.target.name]: value,
  });
}
```

Here you can see that we destructure out the value we want to set to state from the event with `e.target`. Then to access the index to set to state we get the `name` of the input from `e.target` again. Looking at the above code, the name of the input element is `email`.

In turn this will set to state or in this case update the state with the index `email` with the value from the target element.

To summarise:

- We pass in a default state for `email` as an empty string.
- Then use an `onChange` handler to update this state at a later date as the user begins to type in it.

## useEmail

Let's take a look at the next helper function next.

Here's the entire code which we will break down in a second:

```js
import { useState } from "react";

export default function useEmail({ values }) {
  // Setting state to be returned depending on the outcome of the submission.
  const [loading, setLoading] = useState(false);
  const [message, setMessage] = useState("");
  const [error, setError] = useState();

  // destructuring out the values from values passed to this form.
  const { email } = values;

  const serverlessBase = process.env.GATSBY_SERVERLESS_BASE;

  async function submitEmail(e) {
    // Prevent default function of the form submit and set state to defaults for each new submit.
    e.preventDefault();
    setLoading(true);
    setError(null);
    setMessage(null);

    // gathering data to be submitted to the serverless function
    const body = {
      email,
    };

    // Checking there was an email entered.
    if (!email.length) {
      setLoading(false);
      setError(true);
      setMessage("Oops! There was no email entered");
      return;
    }

    // Send the data to the serverless function on submit.
    const res = await fetch(`${serverlessBase}/emailSignup`, {
      method: "POST",
      headers: {
        "Content-Type": "application/json",
      },
      body: JSON.stringify(body),
    });

    // Waiting for the output of the serverless function and storing into the serverlessBaseoutput var.
    const output = JSON.parse(await res.text());

    // check if successful or if was an error
    if (res.status >= 400 && res.status < 600) {
      // Oh no there was an error! Set to state to show user
      setLoading(false);
      setError(true);
      setMessage(output.message);
    } else {
      // everyting worked successfully.
      setLoading(false);
      setMessage(output.message);
    }
  }

  return {
    error,
    loading,
    message,
    submitEmail,
  };
}
```

It's a bit of a long one but it breaks down into logical chunks. Here's what I mean:

1. We create some state with default values, destructure out values from the passed props and get the serverless base from our `.env`

```js
export default function useEmail({ values }) {
  // Setting state to be returned depending on the outcome of the submission.
  const [loading, setLoading] = useState(false);
  const [message, setMessage] = useState("");
  const [error, setError] = useState();

  // destructuring out the values from values passed to this form.
  const { email } = values;

  const serverlessBase = process.env.GATSBY_SERVERLESS_BASE;

  // ... Rest of function
}
```

Because at this point the function hasn't been submitted, the state has been created accordingly so:

```
loading -> false -> Not waiting on anything yet as not submitted
message -> "" -> Not been given any info so blank by default
error -> <EMPTY> -> No error has been generated as not been submitted.
```

Then we destructure out the value we're interested in from the props `email`. This will be passed to the body of the submission in a moment.

Then we get the serverless base from the `.env` file.

[Learn more about Serverless Netlify Functions](https://docs.netlify.com/functions/overview/)

### Defining the submitEmail function

Now, we're going to look at out `submitEmail` function, this is what will be called when the submit button is pressed on the form. (We'll come back to this in a moment.)

```js
async function submitEmail(e) {
  // Prevent default function of the form submit and set state to defaults for each new submit.
  e.preventDefault();
  setLoading(true);
  setError(null);
  setMessage(null);

  // gathering data to be submitted to the serverless function
  const body = {
    email,
  };

  // Checking there was an email entered.
  if (!email.length) {
    setLoading(false);
    setError(true);
    setMessage("Oops! There was no email entered");
    return;
  }

  // Send the data to the serverless function on submit.
  const res = await fetch(`${serverlessBase}/emailSignup`, {
    method: "POST",
    headers: {
      "Content-Type": "application/json",
    },
    body: JSON.stringify(body),
  });

  // Waiting for the output of the serverless function and storing into the output var.
  const output = JSON.parse(await res.text());

  // check if successful or if was an error
  if (res.status >= 400 && res.status < 600) {
    // Oh no there was an error! Set to state to show user
    setLoading(false);
    setError(true);
    setMessage(output.message);
  } else {
    // everyting worked successfully.
    setLoading(false);
    setMessage(output.message);
  }
}
```

Once again, let's break this done into it's steps.

1. First we prevent the default behaviour of the form and update the state values we defined earlier on.

```js
// Prevent default function of the form submit and set state to defaults for each new submit.
e.preventDefault();
setLoading(true);
setError(null);
setMessage(null);
```

2. We then create the body of the request we're going to submit by using the values we destructured out from the props earlier.

```js
// gathering data to be submitted to the serverless function
const body = {
  email,
};
```

3. Before submitting the form, we check the email length if greater than 0 or is truthy. If it isn't then we update the state to be an error, pass a custom error message and return the function.

```js
// Checking there was an email entered.
if (!email.length) {
  setLoading(false);
  setError(true);
  setMessage("Oops! There was no email entered");
  return;
}
```

4. If the email is truthy, then we progress with the submission and do a `POST` request to the serverless function with the `body` we created.

```js
// Send the data to the serverless function on submit.
const res = await fetch(`${serverlessBase}/emailSignup`, {
  method: "POST",
  headers: {
    "Content-Type": "application/json",
  },
  body: JSON.stringify(body),
});
```

5. Then we await the reply from the serverless function and once received convert it to text and parse it with `JSON.parse`.

```js
// Waiting for the output of the serverless function and storing into the output var.
const output = JSON.parse(await res.text());
```

6. Then we get to final part of the submit function, check if the request was successful or not and set the state accordingly.

```js
// check if successful or if was an error
if (res.status >= 400 && res.status < 600) {
  // Oh no there was an error! Set to state to show user
  setLoading(false);
  setError(true);
  setMessage(output.message);
} else {
  // everyting worked successfully.
  setLoading(false);
  setMessage(output.message);
}
```

### Returning data

After we have processed the request, we return the below info back out of the helper function:

```js
return {
  error,
  loading,
  message,
  submitEmail,
};
```

This gives us access to all of the state we defined in the function so we can display it in the component as well as the `submitEmail` function we defined.

### Using it in the Component

Back in the main component, we destructure out the values from the `useEmail` function like so:

```js
const { message, loading, error, submitEmail } \= useEmail({ values });
```

We consume the destructured values in the following places:

1. `onSubmit` function for the form

```js
<FormGridContainer onSubmit={submitEmail}>
```

2. Disabling the submit button if loading is true and changing the text within it.

```js
<button className="signupButton" type="submit" disabled={loading}>
  {loading ? "Subscribing..." : " Subscribe"}
</button>
```

3. Using the display component from earlier to show the message to the user and whether there has been an error or not.

```js
{
  message ? <OutcomeMessageContainer error={error} message={message} /> : "";
}
```

Now we just need to look at the serverless function.

## The Serverless Function

Let's now take a look at how we're going to use the information from the previous `useEmail` function in our serverless function to actually submit the request to ConvertKit.

But, before you can do this you'll need to get yourself an API key and create a form on ConvertKit. If you want to [read more about their API, click here.](https://developers.convertkit.com/)

The API endpoint we will be making use of is:

`https://api.convertkit.com/v3/forms/`

Once you have your form id from the form you created and your API key we can get started.

Here is the full code:

```js
require("isomorphic-fetch");

exports.handler = async (event) => {
  const body = JSON.parse(event.body);

  // Checking we have data from the email input
  const requiredFields = ["email"];

  for (const field of requiredFields) {
    if (!body[field]) {
      return {
        statusCode: 400,
        body: JSON.stringify({
          message: `Oops! You are missing the ${field} field, please fill it in and retry.`,
        }),
      };
    }
  }

  // Setting vars for posting to API
  const endpoint = "https://api.convertkit.com/v3/forms/";
  const APIKey = process.env.CONVERTKIT_PUBLIC_KEY;
  const formID = process.env.CONVERTKIT_SIGNUP_FORM;

  // posting to the Convertkit API
  await fetch(`${endpoint}${formID}/subscribe`, {
    method: "post",
    body: JSON.stringify({
      email: body.email,
      api_key: APIKey,
    }),
    headers: {
      "Content-Type": "application/json",
      charset: "utf-8",
    },
  });
  return {
    statusCode: 200,
    body: JSON.stringify({ message: "Success! Thank you for subscribing! 😃" }),
  };
};
```

Let's walk through this again like we did with the other functions:

1. Parse the JSON body that was sent to us from `useEmail`.

```js
const body = JSON.parse(event.body);
```

2. Check we have filled in the required fields, if not return an error saying it was missed.

```js
// Checking we have data from the email input
const requiredFields = ["email"];

for (const field of requiredFields) {
  if (!body[field]) {
    return {
      statusCode: 400,
      body: JSON.stringify({
        message: `Oops! You are missing the ${field} field, please fill it in and retry.`,
      }),
    };
  }
}
```

3. Get our variables from `.env` and then submit a `POST` request to ConvertKit.

```js
// Setting vars for posting to API
const endpoint = process.env.CONVERTKIT_ENDPOINT;
const APIKey = process.env.CONVERTKIT_PUBLIC_KEY;
const formID = process.env.CONVERTKIT_SIGNUP_FORM;

// posting to the Convertkit API
await fetch(`${endpoint}${formID}/subscribe`, {
  method: "post",
  body: JSON.stringify({
    email: body.email,
    api_key: APIKey,
  }),
  headers: {
    "Content-Type": "application/json",
    charset: "utf-8",
  },
});
```

4. Process the return

```js
return {
  statusCode: 200,
  body: JSON.stringify({ message: "Success! Thank you for subscribing! 😃" }),
};
```

Overall, this is quite a simple flow because we did a lot of heavy lifting in the `useEmail` function we walked through previously.

As long as the required fields are populated we shouldn't have any issues with the request going through.

## The Flow

To round up this post and tie together all of the components we've gone through, let's look at the overall flow of data that happens if everything goes okay:

```
Email Form Component
👇
UseForm -> For storing form info
👇
Email Form Component
👇
useEmail -> onSubmit send the info to the serverless function
👇
Serverless Function -> Submit to ConverKit
👇
Email Form Component -> Display the success message
```

There's a fair amount going on between several files but the flow isn't too complicated. Obviously, if stuff goes wrong then the flow can be short-circuited in different places.

The main 2 places for a short-circuit to happen would be the `useEmail` function and the serverless function.

## Summing Up

I have been running a setup very similar to this on my website now for a few months and haven't had any issues. I like having all of the functions separated into their own files as I do think it improves the readability.

The one thing we could add to improve this setup would be a Honeypot to capture any robots trying to fill in the form. But, I plan on covering this in a separate post.

What do you think of this setup? Let me know over on [Twitter.](https://twitter.com/MrConerMurphy)

I hope you found this post helpful. If you did please consider sharing it with others. If you would like to see more content like this please consider following me on [Twitter.](https://twitter.com/MrConerMurphy)
