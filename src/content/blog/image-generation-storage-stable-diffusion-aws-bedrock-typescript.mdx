---
UUID: ecb7ad67-73a3-4f3e-a912-91f5b8772095
title: 'Image Generation and Storage using Stable Diffusion, AWS Bedrock, and TypeScript'
date: '2023-11-23'
topics: ['AWS', 'BEDROCK', 'LAMBDA', 'S3']
slug: image-generation-stable-diffusion-aws-bedrock-typescript
image:
published: true
description: 'Learn how to generate images using AWS Bedrock and Stable Diffusion using the AWS SDK and how to store them in S3, all provisioned via the AWS CDK.'
canonical_url: ''
imageLink:
---

[In a previous post, we looked at AWS Bedrock and how to generate text using it.](https://conermurphy.com/blog/generating-text-aws-bedrock-lambda-typescript-sdk) However, in this post, we’re going to take that one step further and look at using AWS Bedrock to generate images.

In this tutorial, we’re going to build a simple CDK stack that provisions a Lambda function that will send a request to AWS Bedrock (via the AWS SDK) to generate an image using the Stable Diffusion model. We’ll then take that image and store it in an S3 bucket before returning the URL to the requester so they can download and view the image.

## Configuring Bedrock

Before we can jump in and start building our application in the CDK though, we need to make sure AWS Bedrock is configured for our account. At the time of writing Bedrock is only available in a few AWS regions and the models inside of Bedrock aren’t automatically enabled for all accounts.

Instead, we need to manually go and [request access to each of the models](https://docs.aws.amazon.com/bedrock/latest/userguide/model-access.html) we want to use in our chosen region. For me, I’ll be using the `us-east-1` region but you can use another region if you’d prefer as long as it has access to the Stable Diffusion model.

Once you have Bedrock configured in your target region and you have access to the Stable Diffusion model in that region, we’re ready to get started with the tutorial.

## Setting up Our CDK Stack

To follow along with this tutorial, you’ll need to have a CDK stack, you can use an existing one if you’d like or you can create a new one by running the command `cdk init app --language typescript`. Once you have your CDK stack you need to ensure you’re deploying it to the same region that Bedrock was configured in, this can be configured inside the `bin` directory.

```ts:[]:./bin/*.ts:TYPESCRIPT
#!/usr/bin/env node
import "source-map-support/register";
import * as cdk from "aws-cdk-lib";
import { YourStack } from "../lib/your-stack";

const app = new cdk.App();
new YourStack(app, "YourStack", {
  env: {
    region: "YOUR_REGION",
  },
});
```

**\*NOTE:** You don’t necessarily need to set the CDK region to be the same as the Bedrock region as you can change the region for the Bedrock SDK client independently. But, for the sake of simplicity and to avoid using multiple regions, we’re going to change the entire stack’s region to align with Bedrock.\*

## Defining Resources

Once your CDK stack region and Bedrock are configured, we’re ready to get started with defining the resources we want to provision.

### S3 Bucket

To start, we’re going to define our S3 bucket that will be used to store the images that are generated by Bedrock so that we’re able to download them and view them later on. To define the S3 bucket add the below code to your stack definition file in the `lib` directory.

```ts:[]:./lib/*-stack.ts:TYPESCRIPT
const s3Bucket = new Bucket(this, "ImageBucket", {
  removalPolicy: RemovalPolicy.DESTROY,
  publicReadAccess: true,
  blockPublicAccess: BlockPublicAccess.BLOCK_ACLS,
  cors: [
    {
      allowedHeaders: ["*"],
      allowedMethods: [HttpMethods.GET],
      allowedOrigins: ["*"],
      exposedHeaders: [],
      maxAge: 3000,
    },
  ],
});
```

With this code, we define a new S3 bucket called `ImageBucket` and grant `publicReadAccess` to it so anyone can download the files from it as well as configure CORS to only allow `GET` requests to it.

### Lambda

With our S3 bucket now defined, let’s define our lambda function next. To do this, add the below code under the code we just added for the S3 bucket.

```ts:[]:./lib/*-stack.ts:TYPESCRIPT
new NodejsFunction(this, "ImageLambda", {
  entry: "resources/image-lambda.ts",
  handler: "handler",
  runtime: Runtime.NODEJS_18_X,
  timeout: Duration.minutes(3),
  bundling: {
    nodeModules: ["@aws-sdk/client-bedrock-runtime", "@aws-sdk/client-s3"],
  },
  environment: {
    S3_BUCKET_NAME: s3Bucket.bucketName,
  },
  initialPolicy: [
    new PolicyStatement({
      effect: Effect.ALLOW,
      actions: ["bedrock:*", "s3:*"],
      resources: [`*`],
    }),
  ],
});
```

In this code, we define our new `ImageLambda` lambda function as well as configure some other aspects of the function such as its timeout, runtime, and the file where the code is stored.

However, two properties we need to take a closer look at are the `environment` and the `initialPolicy` properties. With the `environment` property, we provide the name of the S3 bucket to the function so that we can use it inside the function to upload files to the bucket. We then use the `initialPolicy` property to configure a basic IAM policy that allows the Lambda function to interact with S3 and Bedrock.

Now, in a production application, we’d make this policy more restrictive so it only grants the necessary permissions to the resources and not all of them. But, as this is just a tutorial, this policy is ideal because it will allow us to experiment with Bedrock without worrying about IAM permissions preventing us from accessing a model or performing an action against one.

## Writing the Lambda

To start with creating our lambda function, we need to create a new file to contain the function’s code; to do this, create a new file at `./resources/image-lambda.ts`. Inside this file add the below code to it.

```ts:[]:./resources/image-lambda.ts:TYPESCRIPT
import {
  BedrockRuntimeClient,
  InvokeModelCommand,
} from "@aws-sdk/client-bedrock-runtime";
import { PutObjectCommand, S3Client } from "@aws-sdk/client-s3";

const bedrockClient = new BedrockRuntimeClient();
const s3Client = new S3Client();

export const handler = async () => {
  const { S3_BUCKET_NAME = "" } = process.env;

  const prompt = "Developer making an application";
  const fileName = `${prompt.toLowerCase().replaceAll(" ", "_")}.jpg`;

  const input = {
    body: JSON.stringify({
      text_prompts: [
        {
          text: prompt,
        },
      ],
      cfg_scale: 10,
      seed: 0,
      steps: 50,
    }),
    accept: "application/json",
    contentType: "application/json",
    modelId: "stability.stable-diffusion-xl-v0",
  };

  const command = new InvokeModelCommand(input);

  try {
    const response = await bedrockClient.send(command);

    // 1. Get our Base 64 encoded image from the response
    const { artifacts } = JSON.parse(
      new TextDecoder().decode(response.body)
    ) as {
      result: string;
      artifacts: {
        seed: string;
        base64: string;
        finishReason: string;
      }[];
    };

    const imageBase64 = artifacts[0].base64;

    // 2. Decode the Base 64 encoded image
    const decodedImage: Buffer = Buffer.from(imageBase64, "base64");

    // 3. Upload the image to S3
    await s3Client.send(
      new PutObjectCommand({
        Bucket: S3_BUCKET_NAME,
        Key: fileName,
        Body: decodedImage,
      })
    );

    // 4. Create the URL of the image
    const imageUrl = `https://${S3_BUCKET_NAME}.s3.amazonaws.com/${fileName}`;

    // 5. Return the URL of the image
    return {
      statusCode: 200,
      body: imageUrl,
    };
  } catch (e) {
    return {
      statusCode: 500,
      body: e,
    };
  }
};
```

Let’s now walk through what this code does. To start with, we import the required dependencies for S3 and Bedrock from the AWS SDK before creating S3 and Bedrock clients that we’ll use to send commands to AWS.

Then inside our `handler` function, we define the `prompt` we want to send to the Stable Diffusion model on Bedrock before then creating the `fileName` we’re going to be storing the image as on S3.

We then define an `input` object that contains all of the necessary information that Stable Diffusion and Bedrock need to carry out the request and generate an image for us.

At this point, it’s worth noting a couple of things, first of all, you can see inside the `input` object we define a property called `modelId` with a value of `stability.stable-diffusion-xl-v0`, this is how we tell Bedrock what model we want to use. Secondly, the `body` property inside the `input` object is unique to each model so this is the one we require for Stable Diffusion but for different models on Bedrock, you’d need to update this `body` property with different properties and values.

With the `input` object now defined, we then send the request to Bedrock and transform the response so that we have access to the `base64` image data returned to us. We do this with the below code.

```ts
const { artifacts } = JSON.parse(new TextDecoder().decode(response.body)) as {
  result: string
  artifacts: {
    seed: string
    base64: string
    finishReason: string
  }[]
}

const imageBase64 = artifacts[0].base64

// 2. Decode the Base 64 encoded image
const decodedImage: Buffer = Buffer.from(imageBase64, 'base64')
```

Then once we have the decoded image buffer, we can upload the image to S3 using the below code and the `S3_BUCKET_NAME` environment variable we passed in when we defined the Lambda function.

```ts
// 3. Upload the image to S3
await s3Client.send(
  new PutObjectCommand({
    Bucket: S3_BUCKET_NAME,
    Key: fileName,
    Body: decodedImage,
  })
)
```

Finally, we then define the URL where the image will be available and return the image to the requester using the below code.

```ts
// 4. Create the URL of the image
const imageUrl = `https://${S3_BUCKET_NAME}.s3.amazonaws.com/${fileName}`

// 5. Return the URL of the image
return {
  statusCode: 200,
  body: imageUrl,
}
```

At this point, we’ve finished writing the lambda function and our CDK stack overall so in the next section let’s look at deploying and testing our CDK stack by generating an image using the prompt we defined and then downloading it from S3.

## Testing the Image Generation

Before we can test our image generation, we first need to deploy our CDK stack, we can do this by running the command `cdk deploy` in our terminal. Once our CDK stack has finished deploying, we can move on to testing our code.

To do this, we need to invoke our new Lambda function which can be done in various ways such as using the AWS CLI or dashboard. However, I will be using the [VSCode extension “AWS Toolkit”](https://aws.amazon.com/visualstudiocode/) which allows you to manage and invoke your AWS resources from inside VSCode.

After you’ve invoked your Lambda function, you should receive a response with a status code of `200` as well as a URL to the image that was generated by Stable Diffusion and Bedrock. After visiting this URL the generated image should be downloaded to your computer and you should be able to view the image.

So, if you can do all of that then congratulations you have a working project where we can prompt Stable Diffusion to generate an image inside AWS Bedrock and have the generated image uploaded to S3 for us to download.

## Closing Thoughts

To recap, in this post, we’ve looked at [AWS Bedrock](https://aws.amazon.com/bedrock/) and how we can use it to generate images using the Stable Diffusion model before having those images uploaded to an S3 bucket for us to download and view on our local machines.

If you’re interested in checking out the [full example project and CDK stack for this tutorial](https://github.com/conermurphy/cdk-tutorials/tree/main/bedrock-sdk-requests), you can see it over on [my GitHub](https://github.com/conermurphy) along with all of [my other example CDK projects and AWS tutorials](https://github.com/conermurphy/cdk-tutorials/).

I hope you found this post helpful and thanks for reading.
